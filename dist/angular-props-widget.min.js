// angular-props-widget v0.0.1
!function(a,b){"use strict";var c=function(a){return"[object Array]"===Object.prototype.toString.call(a)},d=function(a,b){for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c])};b.module("angular-props-widget",[]).constant("PropsWidgetConfig",{iconlib:"bootstrap3",theme:"bootstrap3",disable_collapse:!0,disable_edit_json:!0,disable_properties:!0,disable_array_add:!0,disable_array_delete:!0,disable_array_reorder:!0,required_by_default:!0}).directive("propsWidget",["$q","PropsWidgetConfig",function(a,e){return{restrict:"E",transclude:!1,require:"ngModel",scope:{schema:"=schema",value:"=ngModel",readonly:"=readonly",onChanged:"&ngChange"},link:function(f,g,h,i,j){if(!b.isString(h.schema))throw new Error("props-widget: schema attribute has to be defined.");var k=function(){var i,j=a.when({}),l=a.when(null);f.isValid=!1,f.isReady=!1,b.isObject(f.schema)&&(l=a.when(f.schema)),b.isObject(f.value)&&(i=f.value,j=a.when(b.isDefined(i.$promise)?i.$promise:i)),a.all([l,j]).then(function(a){var i=a[0].data||a[0],j=a[1];if(null===i)throw new Error("props-widget: could not resolve schema data.");b.extend(e,{startval:j,schema:i}),e.language&&(JSONEditor.defaults.language=e.language),f.editor=new JSONEditor(g[0],e);var l=f.editor;l.on("ready",function(){f.isValid=0===l.validate().length,f.isReady=!0,h.readonly&&l.disable(),f.unbindSchemaWatcher&&f.unbindSchemaWatcher(),f.unbindSchemaWatcher=f.$watch("schema",function(){i!==f.schema&&(f.editor.destroy(),c(f.value)?f.value.length=0:f.value={},k())},!0),f.unbindValueWatcher&&f.unbindValueWatcher(),f.unbindValueWatcher=f.$watch("value",function(){f.isReady&&f.editor.setValue(f.value)},!0)}),l.on("change",function(){f.$apply(function(){if(f.isValid=0===l.validate().length,f.isValid){var a=l.getValue();d(f.value,a),f.onChanged&&f.onChanged()}})})})};k()}}}]).directive("skuTable",["$q","PropsWidgetConfig",function(a,e){var f=function(a){return a.reduce(function(a,b){var c=[];return a.forEach(function(a){b.forEach(function(b){c.push(a.concat([b]))})}),c},[[]])},g=function(a){return a.map(function(a){a.skuProps=a.skuProps||{};for(var b=Object.keys(a.skuProps),c={price:a.price,stock:a.stock,image:a.image},d=0;d<b.length;d+=1){var e=b[d];c[e]=a.skuProps[e]}return c})},h=function(a){return a.map(function(a){for(var b=Object.keys(a),c={skuProps:{},price:a.price,stock:a.stock,image:a.image},d=0;d<b.length;d+=1){var e=b[d];"price"!==e&&"stock"!==e&&"image"!==e&&(c.skuProps[e]=a[e])}return c})};return{restrict:"E",transclude:!1,require:"ngModel",scope:{schema:"=schema",skuProps:"=skuProps",value:"=ngModel",onChanged:"&ngChange"},link:function(i,j,k,l,m){if(!b.isString(k.schema))throw new Error("props-widget: schema attribute has to be defined.");var n=function(){var k,l=a.when({}),m=a.when(null);i.isValid=!1,i.isReady=!1,b.isObject(i.schema)&&(m=a.when(i.schema)),b.isObject(i.value)&&(k=i.value,l=a.when(b.isDefined(k.$promise)?k.$promise:k)),a.all([m,l]).then(function(a){var k=a[0].data||a[0],l=a[1];if(null===k)throw new Error("props-widget: could not resolve schema data.");var m=g(l);b.extend(e,{startval:m,schema:k}),e.language&&(JSONEditor.defaults.language=e.language),i.editor=new JSONEditor(j[0],e);var o=i.editor;o.on("ready",function(){i.isValid=0===o.validate().length,i.isReady=!0,i.unbindSchemaWatcher&&i.unbindSchemaWatcher(),i.unbindSchemaWatcher=i.$watch("schema",function(){k!==i.schema&&(i.editor.destroy(),c(i.value)?i.value.length=0:i.value={},n())}),i.unbindValueWatcher&&i.unbindValueWatcher(),i.unbindValueWatcher=i.$watch("value",function(){if(i.isReady){var a=g(i.value);i.editor.setValue(a)}},!0),i.unbindSkuPropsWatcher&&i.unbindSkuPropsWatcher(),i.unbindSkuPropsWatcher=i.$watch("skuProps",function(a){if(i.isReady){for(var b,c,d=Object.keys(i.skuProps),e=[],g=0;g<d.length;g+=1){b=d[g];var h=i.skuProps[b];e.push(h)}var j=f(e);i.value.length=0,j.forEach(function(a){for(var e={skuProps:{},price:0,stock:0,image:""},f=0;f<d.length;f+=1)b=d[f],c=a[f],e.skuProps[b]=c;i.value.push(e)})}},!0)}),o.on("change",function(){i.$apply(function(){if(i.isValid=0===o.validate().length,i.isValid){var a=o.getValue(),b=h(a);d(i.value,b),i.onChanged&&i.onChanged()}})})})};n()}}}]),JSONEditor.defaults.languages.zh={error_notset:"属性必须设置",error_notempty:"必须值",error_enum:"值必须是枚举值之一",error_anyOf:"值必须是通过提供的Schema之一的校验",error_oneOf:"值必须是仅通过提供的一个Schema之一的校验。它当前通过{{0}}个Schema的校验",error_not:"值必须不能通过提供的Schema验证",error_type_union:"值必须试提供的类型之一",error_type:"值必须是{{0}}类型的",error_disallow_union:"值必须不能是禁止类型之一",error_disallow:"值必须不能是{{0}}类型的",error_multipleOf:"值必须是{{0}}类型数组",error_maximum_excl:"值必须小于{{0}}",error_maximum_incl:"值最大为{{0}}",error_minimum_excl:"值必须大于{{0}}",error_minimum_incl:"值必须最小{{0}}",error_maxLength:"值必须最多{{0}}个字符长",error_minLength:"值必须最少{{0}}个字符长",error_pattern:"值必须匹配提供的模式",error_additionalItems:"这个数组不允许添加额外的元素",error_maxItems:"值必须最多{{0}}项",error_minItems:"值必须最少{{0}}项",error_uniqueItems:"数组元素必须唯一",error_maxProperties:"对象必须最多{{0}}个属性",error_minProperties:"对象必须最少{{0}}个属性",error_required:"对象缺少必须属性{{0}}",error_additional_properties:"不允许额外属性，但属性{{0}}已经设置",error_dependency:"必须有{{0}}属性"}}(window,angular);